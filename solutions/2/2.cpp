// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <gtest/gtest.h>

namespace
{
    struct Solver : public ACSolver
    {
        Answer solvePartOne() override
        {
            // safe if:
            // - all levels are either increasing or decreasing
            // - changes by at least one, but no more than three
            const auto isSafe = [](const std::vector<std::int64_t>& levels)
            {
                std::optional<bool> direction;
                for(std::size_t i = 0; i < levels.size() - 1; ++i)
                {
                    const auto diff = levels[i] - levels[i + 1];
                    if(std::abs(diff) < 1 || std::abs(diff) > 3)
                    {
                        return false;
                    }

                    if(direction.has_value() && direction.value() != (diff > 0))
                    {
                        return false;
                    }
                    else
                    {
                        direction = diff > 0;
                    }
                }

                return true;
            };

            std::int64_t safeLevels = 0;
            for(const auto& line : mInput)
            {
                if(line.empty())
                {
                    break;
                }

                const auto levels = util::ContainerTo<std::int64_t>(util::Split(line));
                if(isSafe(levels))
                {
                    ++safeLevels;
                }
            }

            return safeLevels;
        }

        Answer solvePartTwo() override
        {
            // safe if:
            // - all levels are either increasing or decreasing
            // - changes by at least one, but no more than three
            // - removing one level causes levels to be safe
            const auto isSafe = [](const std::vector<std::int64_t>& levels)
            {
                std::optional<bool> direction;
                for(std::size_t i = 0; i < levels.size() - 1; ++i)
                {
                    const auto diff = levels[i] - levels[i + 1];
                    if(std::abs(diff) < 1 || std::abs(diff) > 3)
                    {
                        return false;
                    }

                    if(direction.has_value() && direction.value() != (diff > 0))
                    {
                        return false;
                    }
                    else
                    {
                        direction = diff > 0;
                    }
                }

                return true;
            };

            std::int64_t safeLevels = 0;
            for(const auto& line : mInput)
            {
                if(line.empty())
                {
                    break;
                }

                const auto levels = util::ContainerTo<std::int64_t>(util::Split(line));
                if(isSafe(levels))
                {
                    ++safeLevels;
                }
                else
                {
                    // I'm not proud of this, but my brain is too small
                    std::size_t skipIndex = 0;
                    while(skipIndex < levels.size())
                    {
                        std::vector<std::int64_t> fewerLevels;
                        for(std::size_t i = 0; const auto level : levels)
                        {
                            if(i != skipIndex)
                            {
                                fewerLevels.push_back(level);
                            }

                            ++i;
                        }

                        if(isSafe(fewerLevels))
                        {
                            ++safeLevels;
                            break;
                        }

                        ++skipIndex;
                    }
                }
            }

            return safeLevels;
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "2_sample.txt" : "2.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_2, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 220);
    std::cout << "part one: " << *answer << std::endl;
}

TEST(day_2, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    ASSERT_GT(*answer, 276);
    // EXPECT_EQ(*answer, INSERT_CORRECT_ANSWER);
    std::cout << "part two: " << *answer << std::endl;
}

TEST(day_2, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 2);
}

TEST(day_2, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 4);
}
