// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <algorithm>
#include <gtest/gtest.h>
#include <vector>

namespace
{
    class XmasFinder
    {
      public:
        // column, row
        using Index = std::pair<std::int32_t, std::int32_t>;

        // start east
        XmasFinder(Index origin)
            : xmas{
                  origin,
                  {origin.first + 1, origin.second},
                  {origin.first + 2, origin.second},
                  {origin.first + 3, origin.second},
              }
        {
        }

        std::uint8_t count(const std::vector<std::string>& x)
        {
            if(const auto first = getLetter(x, xmas[0]); first != 'X' && first != 'S')
            {
                return {};
            }

            std::uint8_t count = 0;

            // east
            if(isXmas(x))
            {
                ++count;
            }

            // southeast
            xmas[1] = {xmas[1].first, xmas[1].second + 1};
            xmas[2] = {xmas[2].first, xmas[2].second + 2};
            xmas[3] = {xmas[3].first, xmas[3].second + 3};
            if(isXmas(x))
            {
                ++count;
            }

            // south
            xmas[1] = {xmas[1].first - 1, xmas[1].second};
            xmas[2] = {xmas[2].first - 2, xmas[2].second};
            xmas[3] = {xmas[3].first - 3, xmas[3].second};
            if(isXmas(x))
            {
                ++count;
            }

            // southwest
            xmas[1] = {xmas[1].first - 1, xmas[1].second};
            xmas[2] = {xmas[2].first - 2, xmas[2].second};
            xmas[3] = {xmas[3].first - 3, xmas[3].second};
            if(isXmas(x))
            {
                ++count;
            }

            return count;
        }

      private:
        bool valid(const std::vector<std::string>& x) const
        {
            return std::ranges::all_of(xmas,
                                       [maxSouth = x.size(), maxEast = x.front().size()](Index i)
                                       {
                                           return i.first >= 0 && i.first < maxEast &&
                                                  i.second >= 0 && i.second < maxSouth;
                                       });
        }

        static char getLetter(const std::vector<std::string>& x, Index i)
        {
            return x[i.first][i.second];
        }

        bool isXmas(const std::vector<std::string>& x) const
        {
            if(!valid(x))
            {
                return false;
            }

            if(const auto first = getLetter(x, xmas[0]); first == 'X')
            {
                return getLetter(x, xmas[1]) == 'M' && getLetter(x, xmas[2]) == 'A' &&
                       getLetter(x, xmas[3]) == 'S';
            }
            else if(first == 'S')
            {
                return getLetter(x, xmas[1]) == 'A' && getLetter(x, xmas[2]) == 'M' &&
                       getLetter(x, xmas[3]) == 'X';
            }

            return false;
        }

        std::array<Index, 4> xmas{};
    };

    class X_MasFinder
    {
      public:
        // column, row
        using Index = std::pair<std::int32_t, std::int32_t>;

        X_MasFinder(Index origin) : mOrigin{origin}
        {
        }

        bool count(const std::vector<std::string>& x)
        {
            if(const auto first = getLetter(x, mOrigin); first != 'A')
            {
                return false;
            }

            const auto ne = Index{mOrigin.first + 1, mOrigin.second - 1};
            const auto se = Index{mOrigin.first + 1, mOrigin.second + 1};
            const auto nw = Index{mOrigin.first - 1, mOrigin.second - 1};
            const auto sw = Index{mOrigin.first - 1, mOrigin.second + 1};

            if(std::ranges::all_of(std::array{ne, se, nw, sw},
                                   [&x](Index i)
                                   {
                                       const auto letter = getLetter(x, i);
                                       return letter == 'M' || letter == 'S';
                                   }))
            {
                return getLetter(x, ne) != getLetter(x, sw) && getLetter(x, nw) != getLetter(x, se);
            }

            return false;
        }

      private:
        static char getLetter(const std::vector<std::string>& x, Index i)
        {
            return x[i.first][i.second];
        }

        Index mOrigin{};
    };
    struct Solver : public ACSolver
    {
        Answer solvePartOne() override
        {
            std::int64_t count = 0;
            for(std::size_t i = 0; i < mInput.size(); ++i)
            {
                for(std::size_t j = 0; j < mInput.size(); ++j)
                {
                    auto finder =
                        XmasFinder({static_cast<std::int32_t>(i), static_cast<std::int32_t>(j)});
                    count += finder.count(mInput);
                }
            }

            return count;
        }

        Answer solvePartTwo() override
        {
            std::int64_t count = 0;
            for(std::size_t i = 1; i < mInput.size() - 1; ++i)
            {
                for(std::size_t j = 1; j < mInput.size() - 1; ++j)
                {
                    auto finder =
                        X_MasFinder({static_cast<std::int32_t>(i), static_cast<std::int32_t>(j)});
                    if(finder.count(mInput))
                    {
                        ++count;
                    }
                }
            }

            return count;
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "4_sample.txt" : "4.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_4, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 2530);
    std::cout << "part one: " << *answer << std::endl;
}

TEST(day_4, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 1921);
    std::cout << "part two: " << *answer << std::endl;
}

TEST(day_4, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 18);
}

TEST(day_4, sample_part_2)
{
    const auto answer = CreateSolver(true).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 9);
}
