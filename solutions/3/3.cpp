// File auto-generated by StartNewDay

#include <ACSolver.ipp>
#include <Utilities.ipp>
#include <gtest/gtest.h>

#include <regex>

namespace
{

    std::pair<std::uint16_t, std::uint16_t> GetOperands(const std::string& x)
    {
        // first is after ( up to ,
        auto start = x.find('(') + 1;
        auto end = x.find(',');
        const auto first = x.substr(start, end - start);

        // second is after , up to )
        start = x.find(',') + 1;
        end = x.find(')');
        const auto second = x.substr(start, end - start);

        return {util::StringTo<std::uint16_t>(first), util::StringTo<std::uint16_t>(second)};
    }

    struct Solver : public ACSolver
    {
        Answer solvePartOne() override
        {
            std::int64_t sum = 0;
            for(auto line : mInput)
            {
                const auto mulRegex = std::regex{R"(mul\(\d{1,3},\d{1,3}\))"};
                for(std::smatch sm; std::regex_search(line, sm, mulRegex);)
                {
                    const auto [first, second] = GetOperands(sm.str());
                    sum += first * second;

                    line = sm.suffix();
                }
            }

            return sum;
        }

        Answer solvePartTwo() override
        {
            // same idea as above, but consider most recent do and don't.
            auto enabled = true;
            std::int64_t sum = 0;
            for(auto line : mInput)
            {
                const auto mulRegex = std::regex{R"(mul\(\d{1,3},\d{1,3}\))"};
                for(std::smatch sm; std::regex_search(line, sm, mulRegex);)
                {
                    const auto doPos = sm.prefix().str().find("do()");
                    const auto dontPos = sm.prefix().str().find("don't()");
                    if(doPos != std::string::npos && dontPos != std::string::npos)
                    {
                        enabled = doPos == dontPos ? false : doPos > dontPos;
                    }
                    else if(doPos != std::string::npos)
                    {
                        enabled = true;
                    }
                    else if(dontPos != std::string::npos)
                    {
                        enabled = false;
                    }

                    if(enabled)
                    {
                        const auto [first, second] = GetOperands(sm.str());
                        sum += first * second;
                    }

                    line = sm.suffix();
                }
            }

            return sum;
        }
    };

    Solver CreateSolver(bool useSample)
    {
        const auto inputFile = useSample ? "3_sample.txt" : "3.txt";
        Solver solver;
        solver.mInput = util::Parse(util::GetInputFile(inputFile));
        return solver;
    }
}

TEST(day_3, part_1)
{
    const auto answer = CreateSolver(false).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 184576302);
    std::cout << "part one: " << *answer << std::endl;
}

TEST(day_3, part_2)
{
    const auto answer = CreateSolver(false).solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 118173507);
    std::cout << "part two: " << *answer << std::endl;
}

TEST(day_3, sample_part_1)
{
    const auto answer = CreateSolver(true).solvePartOne();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 161);
}

TEST(day_3, sample_part_2)
{
    // There's specific input for part 2 so use that
    Solver solver;
    solver.mInput = util::Parse(util::GetInputFile("3_sample_part2.txt"));

    const auto answer = solver.solvePartTwo();
    ASSERT_NE(answer, std::nullopt);
    EXPECT_EQ(*answer, 48);
}
